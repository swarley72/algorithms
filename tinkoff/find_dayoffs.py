# Программист изосим хочет в отпуск длительностью не меньше k дней подряд
# Тимлид инокентий пускает в отпуск если в день отсутствия Изосима будет релиз
# На вход получаем k - минимальную продолжительность отпуска
# и список дней в виде массива чисел 0 (не будет релиза) и 1 (будет релиз)
# Найти количество вариантов для отпуска Изосима, с учетом того что отпуск не должен
# прерываться рабочими днями


def find_dayoffs(k: int, days: list[int]) -> int: ...


assert find_dayoffs(2, [0, 0, 0, 0, 1, 0, 0]) == 7
assert find_dayoffs(2, [0, 0, 1, 0, 0]) == 2
assert find_dayoffs(1, [0, 0, 1, 0]) == 4
assert find_dayoffs(3, [0, 0, 1, 0, 0]) == 0


def find_dayoffs_success(k: int, days: list[int]) -> int:
    begin = 0
    res = 0

    for end in range(len(days)):
        # Если встретили релиз (1), сбрасываем окно
        if days[end] == 1:
            begin = end + 1
            continue
        # Текущая длина окна из нулей
        window_size = end - begin + 1
        # Если длина >= k, добавляем количество способов
        # закончить отпуск в позиции end
        if window_size >= k:
            # Можем начать отпуск с любой позиции от begin до (end - k + 1)
            res += window_size - k + 1

    return res
